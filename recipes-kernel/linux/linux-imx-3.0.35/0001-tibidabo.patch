diff -Naur a/arch/arm/mach-mx6/board-tibidabo.c b/arch/arm/mach-mx6/board-tibidabo.c
--- a/arch/arm/mach-mx6/board-tibidabo.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/arm/mach-mx6/board-tibidabo.c	2014-02-15 16:39:31.069481091 +0100
@@ -0,0 +1,1198 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * 
+ * Copyright (C) 2014 Avnet Emg
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <linux/fec.h>
+#include <linux/clk.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/spi/spi.h>
+#include <linux/memblock.h>
+#include <linux/spi/flash.h>
+#include <linux/netdevice.h>
+#include <linux/fsl_devices.h>
+#include <linux/pwm_backlight.h>
+#include <linux/phy_fixed.h>
+#include <linux/regulator/fixed.h>
+#include <linux/regulator/machine.h>
+
+#include <net/dsa.h>
+
+#include <mach/gpio.h>
+#include <mach/common.h>
+#include <mach/iomux-v3.h>
+#include <mach/hardware.h>
+#include <mach/ahci_sata.h>
+#include <mach/iomux-mx6q.h>
+
+#include <asm/mach/time.h>
+#include <asm/mach/arch.h>
+#include <asm/mach-types.h>
+
+#include "usb.h"
+#include "crm_regs.h"
+#include "devices-imx6q.h"
+
+/****************************** gpios ******************************/
+
+#define DIRECTION_NULL          0
+#define DIRECTION_INPUT         1
+#define DIRECTION_OUTPUT        2
+
+struct tibidabo_gpio_t
+{
+    unsigned int                gpio;
+    char                        *label;
+    char                        direction;
+    char                        output_value;
+    bool                        direction_may_change;
+    iomux_v3_cfg_t              pad;
+};
+
+static struct tibidabo_gpio_t
+    tibidabo_gpios[]            =
+{
+    {
+        .gpio                   = IMX_GPIO_NR( 2, 11 ),
+        .label                  = "GPIO_2_11",
+        .direction              = DIRECTION_OUTPUT,
+        .output_value           = 1,
+        .direction_may_change   = true,
+        .pad                    = MX6Q_PAD_SD4_DAT3__GPIO_2_11,
+    },
+    {
+        .gpio                   = IMX_GPIO_NR( 2, 3 ),
+        .label                  = "GPIO_2_3",
+        .direction              = DIRECTION_INPUT,
+        .direction_may_change   = true,
+        .pad                    = MX6Q_PAD_NANDF_D3__GPIO_2_3,
+    },
+};
+
+static void
+tibidabo_init_gpios(void)
+{
+    int
+        i;
+    for( i = 0; i < ARRAY_SIZE( tibidabo_gpios ); i++ )
+    {
+        mxc_iomux_v3_setup_pad( tibidabo_gpios[ i ].pad );
+        gpio_request( tibidabo_gpios[ i ].gpio, tibidabo_gpios[ i ].label );
+        if( tibidabo_gpios[ i ].direction == DIRECTION_INPUT )
+        {
+            gpio_direction_input( tibidabo_gpios[ i ].gpio );
+        }
+        else if( tibidabo_gpios[ i ].direction == DIRECTION_OUTPUT )
+        {
+            gpio_direction_output( tibidabo_gpios[ i ].gpio, tibidabo_gpios[ i ].output_value );
+        }
+        gpio_export( tibidabo_gpios[ i ].gpio, tibidabo_gpios[ i ].direction_may_change );
+    }
+}
+
+/****************************** sd ******************************/
+
+#define TIBIDABO_SD3_CD             IMX_GPIO_NR( 7, 0 )
+#define TIBIDABO_SD3_WP             IMX_GPIO_NR( 7, 1 )
+
+#define USDHC_PAD_SETTING(id, speed)                        \
+sd##id##_##speed##mhz[] =                                   \
+{                                                           \
+    MX6Q_PAD_SD##id##_CLK__USDHC##id##_CLK_##speed##MHZ,    \
+    MX6Q_PAD_SD##id##_CMD__USDHC##id##_CMD_##speed##MHZ,    \
+    MX6Q_PAD_SD##id##_DAT0__USDHC##id##_DAT0_##speed##MHZ,  \
+    MX6Q_PAD_SD##id##_DAT1__USDHC##id##_DAT1_##speed##MHZ,  \
+    MX6Q_PAD_SD##id##_DAT2__USDHC##id##_DAT2_##speed##MHZ,  \
+    MX6Q_PAD_SD##id##_DAT3__USDHC##id##_DAT3_##speed##MHZ,  \
+}
+
+static iomux_v3_cfg_t USDHC_PAD_SETTING( 3,  50 );
+static iomux_v3_cfg_t USDHC_PAD_SETTING( 3, 100 );
+static iomux_v3_cfg_t USDHC_PAD_SETTING( 3, 200 );
+
+enum sd_pad_mode
+{
+    SD_PAD_MODE_LOW_SPEED,
+    SD_PAD_MODE_MED_SPEED,
+    SD_PAD_MODE_HIGH_SPEED,
+};
+
+static int
+plt_sd_pad_change( unsigned int index, int clock )
+{
+    static enum sd_pad_mode
+        pad_mode                        = SD_PAD_MODE_LOW_SPEED;
+    iomux_v3_cfg_t
+        *sd_pads_200mhz                 = NULL,
+        *sd_pads_100mhz                 = NULL,
+        *sd_pads_50mhz                  = NULL;
+    u32
+        sd_pads_200mhz_cnt,
+        sd_pads_100mhz_cnt,
+        sd_pads_50mhz_cnt;
+
+    if( index == 2 )
+    {
+        sd_pads_200mhz                  = sd3_200mhz;
+        sd_pads_100mhz                  = sd3_100mhz;
+        sd_pads_50mhz                   = sd3_50mhz;
+
+        sd_pads_200mhz_cnt              = ARRAY_SIZE( sd3_200mhz );
+        sd_pads_100mhz_cnt              = ARRAY_SIZE( sd3_100mhz );
+        sd_pads_50mhz_cnt               = ARRAY_SIZE( sd3_50mhz  );
+    }
+    else
+    {
+        printk( KERN_ERR "no such SD host controller index %d\n", index );
+        return -EINVAL;
+    }
+
+    if( clock > 100000000 )
+    {
+        if( pad_mode == SD_PAD_MODE_HIGH_SPEED )
+        {
+            return 0;
+        }
+        BUG_ON( !sd_pads_200mhz );
+        pad_mode                        = SD_PAD_MODE_HIGH_SPEED;
+        return mxc_iomux_v3_setup_multiple_pads( sd_pads_200mhz, sd_pads_200mhz_cnt );
+    }
+    else if( clock > 52000000 )
+    {
+        if( pad_mode == SD_PAD_MODE_MED_SPEED )
+        {
+            return 0;
+        }
+        BUG_ON( !sd_pads_100mhz );
+        pad_mode                        = SD_PAD_MODE_MED_SPEED;
+        return mxc_iomux_v3_setup_multiple_pads( sd_pads_100mhz, sd_pads_100mhz_cnt );
+    }
+    else
+    {
+        if( pad_mode == SD_PAD_MODE_LOW_SPEED )
+        {
+            return 0;
+        }
+        BUG_ON( !sd_pads_50mhz );
+        pad_mode                        = SD_PAD_MODE_LOW_SPEED;
+        return mxc_iomux_v3_setup_multiple_pads( sd_pads_50mhz, sd_pads_50mhz_cnt );
+    }
+}
+
+static const struct esdhc_platform_data
+    tibidabo_sd3_data __initconst       =
+{
+    .cd_gpio                            = TIBIDABO_SD3_CD,
+    .wp_gpio                            = TIBIDABO_SD3_WP,
+    .keep_power_at_suspend              = 1,
+    .platform_pad_change                = plt_sd_pad_change,
+};
+
+static iomux_v3_cfg_t
+    tibidabo_sd3_pads[] =
+{
+    MX6Q_PAD_SD3_CLK__USDHC3_CLK_50MHZ,
+    MX6Q_PAD_SD3_CMD__USDHC3_CMD_50MHZ,
+    MX6Q_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ,
+    MX6Q_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ,
+    MX6Q_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ,
+    MX6Q_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ,
+    MX6Q_PAD_SD3_DAT5__GPIO_7_0,                /* CD */
+    MX6Q_PAD_SD3_DAT4__GPIO_7_1                 /* WP */
+};
+
+static inline void
+tibidabo_init_sd(void)
+{
+    mxc_iomux_v3_setup_multiple_pads( tibidabo_sd3_pads, ARRAY_SIZE( tibidabo_sd3_pads ) );
+    imx6q_add_sdhci_usdhc_imx( 2, &tibidabo_sd3_data );
+}
+
+/****************************** console ******************************/
+
+static iomux_v3_cfg_t
+    tibidabo_console_pads[] =
+{
+    MX6Q_PAD_EIM_D26__UART2_TXD,
+    MX6Q_PAD_EIM_D27__UART2_RXD,
+};
+
+static inline void
+tibidabo_init_console(void)
+{
+    mxc_iomux_v3_setup_multiple_pads( tibidabo_console_pads, ARRAY_SIZE( tibidabo_console_pads ) );
+    imx6q_add_imx_uart( 1, NULL );    
+}
+
+/****************************** timer ******************************/
+
+extern void __iomem
+    *twd_base;
+
+static void __init
+tibidabo_init_timer(void)
+{
+    struct clk
+        *uart_clk;
+    #ifdef CONFIG_LOCAL_TIMERS
+    twd_base            = ioremap( LOCAL_TWD_ADDR, SZ_256 );
+    BUG_ON( !twd_base );
+    #endif
+    mx6_clocks_init( 32768, 24000000, 0, 0 );
+
+    uart_clk            = clk_get_sys( "imx-uart.0", NULL );
+    early_console_setup( UART2_BASE_ADDR, uart_clk );
+}
+
+static struct sys_timer
+    timer_tibidabo      =
+{
+    .init               = tibidabo_init_timer,
+};
+
+/****************************** i2c ******************************/
+
+static struct imxi2c_platform_data
+    tibidabo_i2c_data           =
+{
+    .bitrate                    = 100000,
+};
+
+/* Silica LVDS/Raspberry Pi expansion */
+static iomux_v3_cfg_t
+    tibidabo_i2c1_pads[]        =
+{
+    MX6Q_PAD_CSI0_DAT9__I2C1_SCL,
+    MX6Q_PAD_CSI0_DAT8__I2C1_SDA,
+};
+
+/* HDMI */
+static iomux_v3_cfg_t
+    tibidabo_i2c2_pads[]        =
+{
+    MX6Q_PAD_KEY_COL3__I2C2_SCL,
+    MX6Q_PAD_KEY_ROW3__I2C2_SDA,
+};
+
+/* miniPCIe */
+static iomux_v3_cfg_t
+    tibidabo_i2c3_pads[]        =
+{
+    MX6Q_PAD_GPIO_5__I2C3_SCL,
+    MX6Q_PAD_GPIO_6__I2C3_SDA,
+};
+
+static struct i2c_board_info
+    mxc_i2c1_board_info[] __initdata =
+{
+    {
+        I2C_BOARD_INFO( "mxc_hdmi_i2c", 0x50 ),
+    },
+};
+
+static void
+tibidabo_init_i2c(void)
+{
+    mxc_iomux_v3_setup_multiple_pads( tibidabo_i2c1_pads, ARRAY_SIZE( tibidabo_i2c1_pads ) );
+    mxc_iomux_v3_setup_multiple_pads( tibidabo_i2c2_pads, ARRAY_SIZE( tibidabo_i2c2_pads ) );
+    mxc_iomux_v3_setup_multiple_pads( tibidabo_i2c3_pads, ARRAY_SIZE( tibidabo_i2c3_pads ) );
+
+    imx6q_add_imx_i2c( 0, &tibidabo_i2c_data );
+    imx6q_add_imx_i2c( 1, &tibidabo_i2c_data );
+    imx6q_add_imx_i2c( 2, &tibidabo_i2c_data );
+
+    i2c_register_board_info( 1, mxc_i2c1_board_info, ARRAY_SIZE( mxc_i2c1_board_info ) );
+}
+
+/****************************** usb ******************************/
+#define TIBIDABO_USB_OTG_PWR        IMX_GPIO_NR( 3, 22 )        /* USB_OTG_PWR_EN */
+
+static iomux_v3_cfg_t
+    tibidabo_usb_pads[]             =
+{
+    MX6Q_PAD_EIM_D21__USBOH3_USBOTG_OC,                         /* USB_OTG_OC_B */
+    MX6Q_PAD_ENET_RX_ER__ANATOP_USBOTG_ID,                      /* USB_OTG_ID   */
+};
+
+static void
+tibidabo_usbotg_vbus( bool on )
+{
+    if( on )
+    {
+        gpio_set_value( TIBIDABO_USB_OTG_PWR, 1 );
+    }
+    else
+    {
+        gpio_set_value( TIBIDABO_USB_OTG_PWR, 0 );
+    }
+}
+
+static void __init
+tibidabo_init_usb(void)
+{
+    int
+        ret                         = 0;
+
+    mxc_iomux_v3_setup_multiple_pads( tibidabo_usb_pads, ARRAY_SIZE( tibidabo_usb_pads ) );
+
+    imx_otg_base                    = MX6_IO_ADDRESS(MX6Q_USB_OTG_BASE_ADDR);
+    /* disable external charger detect,
+     * or it will affect signal quality at dp .
+     */
+    ret                             = gpio_request( TIBIDABO_USB_OTG_PWR, "usb-pwr" );
+    if( ret )
+    {
+        pr_err( "failed to get GPIO TIBIDABO_USB_OTG_PWR: %d\n", ret );
+        return;
+    }
+    gpio_direction_output( TIBIDABO_USB_OTG_PWR, 0 );
+    mxc_iomux_set_gpr_register( 1, 13, 1, 1 );
+
+    mx6_set_otghost_vbus_func( tibidabo_usbotg_vbus );
+}
+
+/****************************** spi ******************************/
+
+#define TIBIDABO_ECSPI1_SS1                     IMX_GPIO_NR( 3, 19 )
+
+static iomux_v3_cfg_t
+    tibidabo_spi_pads[]                         =
+{
+    MX6Q_PAD_EIM_D17__ECSPI1_MISO,
+    MX6Q_PAD_EIM_D18__ECSPI1_MOSI,
+    MX6Q_PAD_EIM_D16__ECSPI1_SCLK,
+    MX6Q_PAD_EIM_D19__GPIO_3_19,                /* SS1 */
+};
+
+static int
+    tibidabo_spi_cs[]                           =
+{
+    TIBIDABO_ECSPI1_SS1,
+};
+
+static const struct spi_imx_master
+    tibidabo_spi_data __initconst               =
+{
+    .chipselect                                 = tibidabo_spi_cs,
+    .num_chipselect                             = ARRAY_SIZE( tibidabo_spi_cs ),
+};
+
+static struct mtd_partition
+    tibidabo_spi_nor_partitions[]               =
+{
+    {
+        .name                                   = "bootloader",
+        .offset                                 = 0,
+        .size                                   = 0x01000000,
+    },
+    {
+        .name                                   = "rootfs",
+        .offset                                 = MTDPART_OFS_APPEND,
+        .size                                   = MTDPART_SIZ_FULL,
+    },
+};
+
+static struct flash_platform_data
+    tibidabo_spi_flash_data                     =
+{
+    .name                                       = "n25q00aa",
+    .parts                                      = tibidabo_spi_nor_partitions,
+    .nr_parts                                   = ARRAY_SIZE( tibidabo_spi_nor_partitions ),
+    .type                                       = "n25q00aa",
+};
+
+static struct spi_board_info
+    tibidabo_spi_nor_device[] __initdata        =
+{
+    {
+        .modalias                               = "n25q00aa",
+        .max_speed_hz                           = 20000000,
+        .bus_num                                = 0,
+        .chip_select                            = 0,
+        .platform_data                          = &tibidabo_spi_flash_data,
+    },
+};
+
+static void
+tibidabo_init_spi(void)
+{
+    mxc_iomux_v3_setup_multiple_pads( tibidabo_spi_pads, ARRAY_SIZE( tibidabo_spi_pads ) );
+    imx6q_add_ecspi( 0, &tibidabo_spi_data );
+    spi_register_board_info( tibidabo_spi_nor_device, ARRAY_SIZE( tibidabo_spi_nor_device ) );
+}
+
+/****************************** dsa ******************************/
+
+static struct dsa_chip_data
+    chip_data                                   = 
+{
+    .mii_bus                                    = NULL,
+    .rtable                                     = NULL,
+    .sw_addr                                    = 0x0,
+    .port_names                                 = { "pt0", "pt1", NULL, NULL, NULL, "cpu", NULL, NULL, NULL, NULL, NULL, NULL },
+};
+
+static struct dsa_platform_data
+    dsa_data                                    =
+{    
+    .nr_chips                                   = 1,
+    .chip                                       = &chip_data,
+    .netdev                                     = NULL,
+};
+
+struct imx_dsa_data
+{
+    resource_size_t                             iobase;
+    resource_size_t                             irq;
+    const char                                  *devid;
+};
+
+const struct imx_dsa_data
+    imx6q_dsa_data                              =
+{
+    .iobase                                     = MX6Q_FEC_BASE_ADDR,
+    .irq                                        = MX6Q_INT_FEC,
+    .devid                                      = "dsa",
+};
+
+static struct platform_device*
+imx_add_dsa( const struct imx_dsa_data *data, const struct dsa_platform_data *pdata )
+{
+    struct resource
+        res[]                                   =
+    {
+        {
+            .start                              = data->iobase,
+            .end                                = data->iobase + SZ_4K - 1,
+            .flags                              = IORESOURCE_MEM,
+        },
+        {
+            .start                              = data->irq,
+            .end                                = data->irq,
+            .flags                              = IORESOURCE_IRQ,
+        },
+    };
+
+    return imx_add_platform_device_dmamask( data->devid, 0, res, ARRAY_SIZE( res ), pdata, sizeof( *pdata ), DMA_BIT_MASK( 32 ) );
+}
+
+static void imx6_init_dsa( struct dsa_platform_data dsa_data )
+{
+    imx_add_dsa( &imx6q_dsa_data, &dsa_data );
+}
+
+/****************************** ethernet ******************************/
+
+static iomux_v3_cfg_t
+    tibidabo_mdio_pads[]            =
+{
+    MX6Q_PAD_ENET_MDIO__ENET_MDIO,
+    MX6Q_PAD_ENET_MDC__ENET_MDC,
+};
+
+static iomux_v3_cfg_t
+    tibidabo_fec_pads[]             =
+{
+    MX6Q_PAD_RGMII_TXC__ENET_RGMII_TXC,
+    MX6Q_PAD_RGMII_TD0__ENET_RGMII_TD0,
+    MX6Q_PAD_RGMII_TD1__ENET_RGMII_TD1,
+    MX6Q_PAD_RGMII_TD2__ENET_RGMII_TD2,
+    MX6Q_PAD_RGMII_TD3__ENET_RGMII_TD3,
+    MX6Q_PAD_RGMII_TX_CTL__ENET_RGMII_TX_CTL,
+    MX6Q_PAD_ENET_REF_CLK__ENET_TX_CLK,
+    MX6Q_PAD_RGMII_RXC__ENET_RGMII_RXC,
+    MX6Q_PAD_RGMII_RD0__ENET_RGMII_RD0,
+    MX6Q_PAD_RGMII_RD1__ENET_RGMII_RD1,
+    MX6Q_PAD_RGMII_RD2__ENET_RGMII_RD2,
+    MX6Q_PAD_RGMII_RD3__ENET_RGMII_RD3,
+    MX6Q_PAD_RGMII_RX_CTL__ENET_RGMII_RX_CTL,
+    MX6Q_PAD_ENET_TX_EN__GPIO_1_28,                 /* RGMII_INT_B */
+    MX6Q_PAD_EIM_D23__GPIO_3_23,                    /* RGMII_RST_B */
+#ifdef CONFIG_FEC_1588
+    MX6Q_PAD_GPIO_16__ENET_ANATOP_ETHERNET_REF_OUT, /* The pin must be left unconnected for 1588 to work properly */
+#endif   
+};
+
+static int
+tibidabo_fec_phy_init( struct phy_device *phydev )
+{
+    return 0;
+}
+
+static struct fec_platform_data
+    tibidabo_fec_data __initdata    =
+{
+    .init                           = tibidabo_fec_phy_init,
+    .phy                            = PHY_INTERFACE_MODE_RGMII,
+};
+
+static struct fixed_phy_status
+    phy_stat __initdata             =
+{
+    .link                           = 1,
+    .speed                          = 1000,
+    .duplex                         = 1,
+};
+
+static void
+tibidabo_init_fec(void)
+{
+    struct platform_device
+        *pdev;
+    mxc_iomux_v3_setup_multiple_pads( tibidabo_mdio_pads, ARRAY_SIZE( tibidabo_mdio_pads ) );
+    mxc_iomux_v3_setup_multiple_pads( tibidabo_fec_pads,  ARRAY_SIZE( tibidabo_fec_pads  ) );
+#ifdef CONFIG_FEC_1588
+	/* Set GPIO_16 input for IEEE-1588 ts_clk and RMII reference clock
+	 * For MX6 GPR1 bit21 meaning:
+	 * Bit21:       0 - GPIO_16 pad output
+	 *              1 - GPIO_16 pad input
+	 */
+	mxc_iomux_set_gpr_register( 1, 21, 1, 1 );
+#endif   
+    fixed_phy_add( PHY_POLL, 0, &phy_stat );
+    pdev                            = imx6_init_fec( tibidabo_fec_data );
+    dsa_data.netdev                 = &( pdev->dev );
+    dsa_data.chip->mii_bus          = dsa_data.netdev;
+    imx6_init_dsa( dsa_data );
+}
+
+
+/****************************** anatop ******************************/
+/*
+    Anatop is an integrated regulator inside i.MX6 SoC.
+*/
+
+static const struct anatop_thermal_platform_data
+    tibidabo_anatop_thermal_data __initconst    = 
+{
+    .name                                       = "anatop_thermal",
+};
+
+static void
+tibidabo_init_anatop(void)
+{
+    imx6q_add_anatop_thermal_imx( 1, &tibidabo_anatop_thermal_data );
+}
+
+/****************************** power management ******************************/
+
+static void
+tibidabo_suspend_enter(void)
+{
+    /* suspend preparation */
+}
+
+static void
+tibidabo_suspend_exit(void)
+{
+    /* resume restore */
+}
+
+static const struct pm_platform_data
+    tibidabo_pm_data __initconst    =
+{
+    .name                           = "imx_pm",
+    .suspend_enter                  = tibidabo_suspend_enter,
+    .suspend_exit                   = tibidabo_suspend_exit,
+};
+
+static void
+tibidabo_init_pm(void)
+{
+    imx6q_add_pm_imx( 0, &tibidabo_pm_data );
+}
+
+/****************************** mSATA ******************************/
+
+static struct clk
+    *sata_clk;
+
+/* HW Initialization, if return 0, initialization is successful. */
+static int
+tibidabo_sata_init( struct device *dev, void __iomem *addr )
+{
+    u32
+        tmpdata;
+    int
+        ret                     = 0;
+    struct clk
+        *clk;
+
+    sata_clk                    = clk_get( dev, "imx_sata_clk" );
+    if( IS_ERR( sata_clk ) )
+    {
+        dev_err( dev, "no sata clock.\n" );
+        return PTR_ERR( sata_clk );
+    }
+    ret                         = clk_enable( sata_clk );
+    if( ret )
+    {
+        dev_err( dev, "can't enable sata clock.\n" );
+        goto put_sata_clk;
+    }
+
+    /* Set PHY Paremeters, two steps to configure the GPR13,
+     * one write for rest of parameters, mask of first write is 0x07FFFFFD,
+     * and the other one write for setting the mpll_clk_off_b
+     *.rx_eq_val_0(iomuxc_gpr13[26:24]),
+     *.los_lvl(iomuxc_gpr13[23:19]),
+     *.rx_dpll_mode_0(iomuxc_gpr13[18:16]),
+     *.sata_speed(iomuxc_gpr13[15]),
+     *.mpll_ss_en(iomuxc_gpr13[14]),
+     *.tx_atten_0(iomuxc_gpr13[13:11]),
+     *.tx_boost_0(iomuxc_gpr13[10:7]),
+     *.tx_lvl(iomuxc_gpr13[6:2]),
+     *.mpll_ck_off(iomuxc_gpr13[1]),
+     *.tx_edgerate_0(iomuxc_gpr13[0]),
+     */
+    tmpdata                     = readl( IOMUXC_GPR13 );
+    writel( ( ( tmpdata & ~0x07FFFFFD ) | 0x0593A044 ), IOMUXC_GPR13 );
+
+    /* enable SATA_PHY PLL */
+    tmpdata                     = readl( IOMUXC_GPR13 );
+    writel( ( ( tmpdata & ~0x2 ) | 0x2 ), IOMUXC_GPR13 );
+
+    /* Get the AHB clock rate, and configure the TIMER1MS reg later */
+    clk                         = clk_get( NULL, "ahb" );
+    if( IS_ERR( clk ) )
+    {
+        dev_err( dev, "no ahb clock.\n" );
+        ret                     = PTR_ERR( clk );
+        goto release_sata_clk;
+    }
+    tmpdata                     = clk_get_rate( clk ) / 1000;
+    clk_put( clk );
+
+    ret                         = sata_init( addr, tmpdata );
+    if( ret == 0 )
+    {
+        return ret;
+    }
+release_sata_clk:
+    clk_disable( sata_clk );
+put_sata_clk:
+    clk_put( sata_clk );
+
+    return ret;
+}
+
+static void
+tibidabo_sata_exit( struct device *dev )
+{
+    clk_disable( sata_clk );
+    clk_put( sata_clk );
+}
+
+static struct ahci_platform_data
+    tibidabo_sata_data          =
+{
+    .init                       = tibidabo_sata_init,
+    .exit                       = tibidabo_sata_exit,
+};
+
+static void
+tibidabo_init_sata(void)
+{
+    imx6q_add_ahci( 0, &tibidabo_sata_data );
+}
+
+/****************************** clocks ******************************/
+
+static void
+tibidabo_init_clocks(void)
+{
+    struct clk
+        *clko2,
+        *new_parent;
+    int
+        rate;
+    clko2                       = clk_get( NULL, "clko2_clk" );
+    if( IS_ERR( clko2 ) )
+    {
+        pr_err( "can't get CLKO2 clock.\n" );
+    }
+
+    new_parent                  = clk_get( NULL, "osc_clk" );
+    if( !IS_ERR( new_parent ) )
+    {
+        clk_set_parent( clko2, new_parent );
+        clk_put( new_parent );
+    }
+    rate                        = clk_round_rate( clko2, 24000000 );
+    clk_set_rate( clko2, rate );
+    clk_enable( clko2 );
+}
+
+/****************************** perfmon ******************************/
+
+static void
+tibidabo_init_perfmon(void)
+{
+    imx6q_add_perfmon( 0 );
+    imx6q_add_perfmon( 1 );
+    imx6q_add_perfmon( 2 );
+}
+
+/****************************** dynamic voltage frequency scaling ******************************/
+
+extern char
+    *gp_reg_id,
+    *soc_reg_id,
+    *pu_reg_id;
+
+static struct mxc_dvfs_platform_data
+    tibidabo_dvfscore_data      =
+{
+    .reg_id                     = "cpu_vddgp",
+    .soc_id                     = "cpu_vddsoc",
+    .pu_id                      = "cpu_vddvpu",
+    .clk1_id                    = "cpu_clk",
+    .clk2_id                    = "gpc_dvfs_clk",
+    .gpc_cntr_offset            = MXC_GPC_CNTR_OFFSET,
+    .ccm_cdcr_offset            = MXC_CCM_CDCR_OFFSET,
+    .ccm_cacrr_offset           = MXC_CCM_CACRR_OFFSET,
+    .ccm_cdhipr_offset          = MXC_CCM_CDHIPR_OFFSET,
+    .prediv_mask                = 0x1F800,
+    .prediv_offset              = 11,
+    .prediv_val                 = 3,
+    .div3ck_mask                = 0xE0000000,
+    .div3ck_offset              = 29,
+    .div3ck_val                 = 2,
+    .emac_val                   = 0x08,
+    .upthr_val                  = 25,
+    .dnthr_val                  = 9,
+    .pncthr_val                 = 33,
+    .upcnt_val                  = 10,
+    .dncnt_val                  = 10,
+    .delay_time                 = 80,
+};
+
+static void
+tibidabo_init_dvfs(void)
+{
+    gp_reg_id                   = tibidabo_dvfscore_data.reg_id;
+    soc_reg_id                  = tibidabo_dvfscore_data.soc_id;
+    pu_reg_id                   = tibidabo_dvfscore_data.pu_id;
+    imx6q_add_dvfs_core( &tibidabo_dvfscore_data );
+}
+
+/****************************** pwm ******************************/
+
+static struct platform_pwm_backlight_data
+    tibidabo_pwm_backlight_data =
+{
+    .pwm_id                     = 3,
+    .max_brightness             = 255,
+    .dft_brightness             = 128,
+    .pwm_period_ns              = 50000,
+};
+
+static void
+tibidabo_init_pwm(void)
+{
+    imx6q_add_mxc_pwm( 0 );
+    imx6q_add_mxc_pwm( 1 );
+    imx6q_add_mxc_pwm( 2 );
+    imx6q_add_mxc_pwm( 3 );
+    imx6q_add_mxc_pwm_backlight( 3, &tibidabo_pwm_backlight_data );
+}
+
+/****************************** video ******************************/
+
+struct imx_vout_mem
+{
+	resource_size_t             res_mbase;
+	resource_size_t             res_msize;
+};
+
+static struct imx_vout_mem
+    vout_mem __initdata         =
+{
+	.res_msize                  = SZ_128M,
+};
+
+static struct fsl_mxc_hdmi_core_platform_data
+    hdmi_core_data              =
+{
+    .ipu_id                     = 0,
+    .disp_id                    = 0,
+};
+
+static struct imx_ipuv3_platform_data
+    ipu_data[]                  =
+{
+    {
+        .rev                    = 4,
+        .csi_clk[ 0 ]           = "clko2_clk",
+    },
+    {
+        .rev                    = 4,
+        .csi_clk[ 0 ]           = "clko2_clk",
+    },
+};
+
+static struct ipuv3_fb_platform_data
+    tibidabo_fb_data[]          =
+{
+    { /*fb0*/
+        .disp_dev               = "ldb",
+        .interface_pix_fmt      = IPU_PIX_FMT_RGB666,
+        .mode_str               = "LDB-XGA",
+        .default_bpp            = 16,
+        .int_clk                = false,
+    },
+    {
+        .disp_dev               = "lcd",
+        .interface_pix_fmt      = IPU_PIX_FMT_RGB565,
+        .mode_str               = "CLAA-WVGA",
+        .default_bpp            = 16,
+        .int_clk                = false,
+    },
+    {
+        .disp_dev               = "ldb",
+        .interface_pix_fmt      = IPU_PIX_FMT_RGB666,
+        .mode_str               = "LDB-SVGA",
+        .default_bpp            = 16,
+        .int_clk                = false,
+    },
+    {
+        .disp_dev               = "ldb",
+        .interface_pix_fmt      = IPU_PIX_FMT_RGB666,
+        .mode_str               = "LDB-VGA",
+        .default_bpp            = 16,
+        .int_clk                = false,
+    },
+};
+
+static struct fsl_mxc_lcd_platform_data
+    lcdif_data                  =
+{
+    .ipu_id                     = 0,
+    .disp_id                    = 0,
+    .default_ifmt               = IPU_PIX_FMT_RGB565,
+};
+
+static struct fsl_mxc_ldb_platform_data
+    ldb_data                    =
+{
+    .ipu_id                     = 1,
+    .disp_id                    = 0,
+    .ext_ref                    = 1,
+    .mode                       = LDB_SEP0,
+    .sec_ipu_id                 = 1,
+    .sec_disp_id                = 1,
+};
+
+static struct fsl_mxc_capture_platform_data
+    capture_data[]              =
+{
+    {
+        .csi                    = 0,
+        .ipu                    = 0,
+        .mclk_source            = 0,
+        .is_mipi                = 0,
+    },
+    {
+        .csi                    = 1,
+        .ipu                    = 0,
+        .mclk_source            = 0,
+        .is_mipi                = 1,
+    },
+};
+
+static struct mipi_csi2_platform_data
+    mipi_csi2_pdata             =
+{
+    .ipu_id                     = 0,
+    .csi_id                     = 0,
+    .v_channel                  = 0,
+    .lanes                      = 2,
+    .dphy_clk                   = "mipi_pllref_clk",
+    .pixel_clk                  = "emi_clk",
+};
+
+static void
+hdmi_init( int ipu_id, int disp_id )
+{
+    int
+        hdmi_mux_setting;
+
+    if( ( ipu_id > 1 ) || ( ipu_id < 0 ) )
+    {
+        pr_err( "Invalid IPU select for HDMI: %d. Set to 0\n", ipu_id );
+        ipu_id                  = 0;
+    }
+
+    if( ( disp_id > 1 ) || ( disp_id < 0 ) )
+    {
+        pr_err( "Invalid DI select for HDMI: %d. Set to 0\n", disp_id );
+        disp_id                 = 0;
+    }
+
+    /* Configure the connection between IPU1/2 and HDMI */
+    hdmi_mux_setting            = 2 * ipu_id + disp_id;
+
+    /* GPR3, bits 2-3 = HDMI_MUX_CTL */
+    mxc_iomux_set_gpr_register( 3, 2, 2, hdmi_mux_setting );
+
+    /* Set HDMI event as SDMA event2 while Chip version later than TO1.2 */
+    if( ( mx6q_revision() > IMX_CHIP_REVISION_1_1 ) )
+        mxc_iomux_set_gpr_register( 0, 0, 1, 1 );
+}
+
+static iomux_v3_cfg_t
+    tibidabo_hdmi_ddc_pads[]    = 
+{
+    MX6Q_PAD_KEY_COL3__HDMI_TX_DDC_SCL,
+    MX6Q_PAD_KEY_ROW3__HDMI_TX_DDC_SDA,
+};
+
+static void
+hdmi_enable_ddc_pin( void )
+{
+    mxc_iomux_v3_setup_multiple_pads( tibidabo_hdmi_ddc_pads, ARRAY_SIZE( tibidabo_hdmi_ddc_pads ) );
+}
+
+static void
+hdmi_disable_ddc_pin( void )
+{
+    mxc_iomux_v3_setup_multiple_pads( tibidabo_i2c2_pads, ARRAY_SIZE( tibidabo_i2c2_pads ) );
+}
+
+static struct fsl_mxc_hdmi_platform_data
+    hdmi_data                   =
+{
+    .init                       = hdmi_init,
+    .enable_pins                = hdmi_enable_ddc_pin,
+    .disable_pins               = hdmi_disable_ddc_pin,
+};
+
+static struct viv_gpu_platform_data
+    imx6q_gpu_pdata __initdata  =
+{
+    .reserved_mem_size          = SZ_128M,
+};
+
+static void
+tibidabo_init_video_and_graphics(void)
+{
+    int
+        i;
+    struct platform_device
+        *voutdev;
+    imx6q_add_mxc_hdmi_core( &hdmi_core_data );
+
+    imx6q_add_ipuv3( 0, &ipu_data[ 0 ] );                       /* image processing unit v3 (ipuv3) */
+    imx6q_add_ipuv3( 1, &ipu_data[ 1 ] );
+    for( i = 0; i < ARRAY_SIZE( tibidabo_fb_data ); i++ )
+    {
+        imx6q_add_ipuv3fb( i, &tibidabo_fb_data[ i ] );
+    }
+
+    imx6q_add_vdoa();                                           /* video data order adapter */
+    imx6q_add_lcdif( &lcdif_data );
+    imx6q_add_ldb( &ldb_data );
+    voutdev                     = imx6q_add_v4l2_output( 0 );   /* video for linux */
+ 	if( vout_mem.res_msize && voutdev )
+    {
+		dma_declare_coherent_memory(    &voutdev->dev,
+					                    vout_mem.res_mbase,
+					                    vout_mem.res_mbase,
+					                    vout_mem.res_msize,
+                                        ( DMA_MEMORY_MAP | DMA_MEMORY_EXCLUSIVE ) );
+	}   
+    imx6q_add_v4l2_capture( 0, &capture_data[ 0 ] );        
+    imx6q_add_v4l2_capture( 1, &capture_data[ 1 ] );        
+    imx6q_add_mipi_csi2( &mipi_csi2_pdata );                    /* Mobile Industry Processor Interface */
+    imx6q_add_mxc_hdmi( &hdmi_data );
+    imx_add_viv_gpu( &imx6_gpu_data, &imx6q_gpu_pdata );
+    imx6q_add_vpu();                                            /* Video Processing Unit */
+	imx6q_add_hdmi_soc();
+	imx6q_add_hdmi_soc_dai();
+}
+
+/****************************** asrc ******************************/
+
+static struct imx_asrc_platform_data
+    imx_asrc_data                   =
+{
+	.channel_bits                   = 4,
+	.clk_map_ver                    = 2,
+};
+
+static void tibidabo_init_asrc(void)
+{
+	imx_asrc_data.asrc_core_clk     = clk_get( NULL, "asrc_clk" );
+	imx_asrc_data.asrc_audio_clk    = clk_get( NULL, "asrc_serial_clk" );
+	imx6q_add_asrc( &imx_asrc_data );
+}
+
+/****************************** pcie ******************************/
+
+#define TIBIDABO_PCIE_RST_B_REVB    IMX_GPIO_NR( 7, 12 )
+#define TIBIDABO_PCIE_WAKE_B        IMX_GPIO_NR( 5, 20 )
+#define TIBIDABO_PCIE_PWR_EN        -EINVAL
+#define TIBIDABO_PCIE_DIS_B         -EINVAL
+
+static iomux_v3_cfg_t
+    tibidabo_pcie_pads[]            = 
+{
+    MX6Q_PAD_KEY_COL4__GPIO_4_14,                           /* PCIE_DIS_B  */
+    MX6Q_PAD_GPIO_17__GPIO_7_12,                            /* PCIE_RST_B  */
+    MX6Q_PAD_CSI0_DATA_EN__GPIO_5_20,                       /* PCIE_WAKE_B */
+};
+
+static const struct imx_pcie_platform_data
+    tibidabo_pcie_data __initconst  =
+{
+    .pcie_pwr_en                    = TIBIDABO_PCIE_PWR_EN,
+    .pcie_rst                       = TIBIDABO_PCIE_RST_B_REVB,
+    .pcie_wake_up                   = TIBIDABO_PCIE_WAKE_B,
+    .pcie_dis                       = TIBIDABO_PCIE_DIS_B,
+};
+
+static void
+pcie_reset(void)
+{
+    /* reset miniPCIe */
+    gpio_request( TIBIDABO_PCIE_RST_B_REVB, "pcie_reset_revB" );
+    gpio_direction_output( TIBIDABO_PCIE_RST_B_REVB, 0 );
+    /* The PCI Express Mini CEM specification states that PREST# is
+    deasserted minimum 1ms after 3.3vVaux has been applied and stable*/
+    mdelay( 1 );
+    gpio_set_value( TIBIDABO_PCIE_RST_B_REVB, 1 );
+    gpio_free( TIBIDABO_PCIE_RST_B_REVB );
+}
+
+static void
+tibidabo_init_pcie(void)
+{
+    mxc_iomux_v3_setup_multiple_pads( tibidabo_pcie_pads, ARRAY_SIZE( tibidabo_pcie_pads ) );
+    pcie_reset();
+    imx6q_add_pcie( &tibidabo_pcie_data );
+}
+
+/****************************** vmmc ******************************/
+
+static struct regulator_consumer_supply
+    tibidabo_vmmc_consumers[]       =
+{
+	REGULATOR_SUPPLY( "vmmc", "sdhci-esdhc-imx.2" )
+};
+
+static struct regulator_init_data
+    tibidabo_vmmc_init              =
+{
+	.num_consumer_supplies          = ARRAY_SIZE( tibidabo_vmmc_consumers ),
+	.consumer_supplies              = tibidabo_vmmc_consumers,
+};
+
+static struct fixed_voltage_config
+    tibidabo_vmmc_reg_config        =
+{
+	.supply_name                    = "vmmc",
+	.microvolts		                = 3300000,
+	.gpio			                = -1,
+	.init_data		                = &tibidabo_vmmc_init,
+};
+
+static struct platform_device
+    tibidabo_vmmc_reg_devices       =
+{
+	.name                           = "reg-fixed-voltage",
+    .id                             = 2,
+	.dev	                        =
+    {
+		.platform_data              = &tibidabo_vmmc_reg_config,
+	},
+};
+
+static void tibidabo_init_vmmc(void)
+{
+	platform_device_register( &tibidabo_vmmc_reg_devices );
+}
+
+/****************************** machine functions ******************************/
+
+static void __init fixup_tibidabo( struct machine_desc *desc, struct tag *tags, char **cmdline, struct meminfo *mi )
+{
+}
+
+static void __init reserve_tibidabo(void)
+{
+    #if defined(CONFIG_MXC_GPU_VIV) || defined(CONFIG_MXC_GPU_VIV_MODULE)
+    phys_addr_t
+        phys;
+
+    if( imx6q_gpu_pdata.reserved_mem_size )
+    {
+        phys                                        = memblock_alloc_base( imx6q_gpu_pdata.reserved_mem_size, SZ_4K, SZ_1G );
+        memblock_remove( phys, imx6q_gpu_pdata.reserved_mem_size );
+        imx6q_gpu_pdata.reserved_mem_base           = phys;
+    }
+    #endif
+ 	if( vout_mem.res_msize )
+    {
+		phys                                        = memblock_alloc_base( vout_mem.res_msize, SZ_4K, SZ_1G );
+		memblock_remove( phys, vout_mem.res_msize );
+		vout_mem.res_mbase                          = phys;
+	}   
+}
+
+static void __init init_machine_tibidabo(void)
+{
+    tibidabo_init_console();
+    tibidabo_init_dvfs();
+    tibidabo_init_clocks();
+    imx6q_add_imx_snvs_rtc();
+    imx6q_add_imx_caam();
+    imx6q_add_otp();
+    imx6q_add_imx2_wdt( 0, NULL );
+    imx6q_add_dma();
+    imx6q_add_viim();
+    tibidabo_init_pwm();
+    tibidabo_init_i2c();
+    tibidabo_init_usb();
+    tibidabo_init_fec();
+    tibidabo_init_spi();
+    tibidabo_init_anatop();
+    tibidabo_init_pm();
+    tibidabo_init_sata();
+    tibidabo_init_sd();
+    imx6q_add_busfreq();
+    tibidabo_init_perfmon();
+    tibidabo_init_video_and_graphics();
+    tibidabo_init_asrc();
+    tibidabo_init_pcie();
+    tibidabo_init_gpios();
+    tibidabo_init_vmmc();
+}
+
+/****************************** machine definition ******************************/
+
+MACHINE_START(TIBIDABO, "Architech Tibidabo board")
+    /* Maintainer Avnet Emg */
+    .boot_params        = MX6_PHYS_OFFSET + 0x100,
+    .fixup              = fixup_tibidabo,
+    .map_io             = mx6_map_io,
+    .init_irq           = mx6_init_irq,
+    .init_machine       = init_machine_tibidabo,
+    .timer              = &timer_tibidabo,
+    .reserve            = reserve_tibidabo,
+MACHINE_END
diff -Naur a/arch/arm/mach-mx6/Kconfig b/arch/arm/mach-mx6/Kconfig
--- a/arch/arm/mach-mx6/Kconfig	2014-01-09 09:24:59.943252522 +0100
+++ b/arch/arm/mach-mx6/Kconfig	2014-01-09 12:16:18.952809906 +0100
@@ -282,6 +282,43 @@
 	  Include support for i.MX 6Quad HDMI Dongle platform. This includes specific
 	  configurations for the board and its peripherals.
 
+config MACH_TIBIDABO
+	bool "Support i.MX 6Quad TIBIDABO platform"
+	select ARCH_MX6Q
+	select SOC_IMX6Q
+	select IMX_HAVE_PLATFORM_IMX_UART
+	select IMX_HAVE_PLATFORM_DMA
+	select IMX_HAVE_PLATFORM_FEC
+	select IMX_HAVE_PLATFORM_GPMI_NFC
+	select IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX
+	select IMX_HAVE_PLATFORM_SPI_IMX
+	select IMX_HAVE_PLATFORM_IMX_I2C
+	select IMX_HAVE_PLATFORM_VIV_GPU
+	select IMX_HAVE_PLATFORM_IMX_VPU
+	select IMX_HAVE_PLATFORM_IMX_SSI
+	select IMX_HAVE_PLATFORM_IMX_ANATOP_THERMAL
+	select IMX_HAVE_PLATFORM_FSL_USB2_UDC
+	select IMX_HAVE_PLATFORM_MXC_EHCI
+	select IMX_HAVE_PLATFORM_FSL_OTG
+	select IMX_HAVE_PLATFORM_FSL_USB_WAKEUP
+	select IMX_HAVE_PLATFORM_AHCI
+	select IMX_HAVE_PLATFORM_IMX_OCOTP
+	select IMX_HAVE_PLATFORM_IMX_VIIM
+	select IMX_HAVE_PLATFORM_IMX2_WDT
+	select IMX_HAVE_PLATFORM_IMX_SNVS_RTC
+	select IMX_HAVE_PLATFORM_IMX_PM
+	select IMX_HAVE_PLATFORM_MXC_HDMI
+	select IMX_HAVE_PLATFORM_IMX_ASRC
+	select IMX_HAVE_PLATFORM_FLEXCAN
+	select IMX_HAVE_PLATFORM_IMX_CAAM
+    select IMX_HAVE_PLATFORM_IMX_MIPI_CSI2
+    select IMX_HAVE_PLATFORM_IMX_DVFS
+    select IMX_HAVE_PLATFORM_PERFMON
+    select IMX_HAVE_PLATFORM_IMX_PCIE
+	help
+	  Include support for Tibidabo platform. This includes specific
+	  configurations for the board and its peripherals.
+
 comment "MX6 Options:"
 
 config IMX_PCIE
diff -Naur a/arch/arm/mach-mx6/Makefile b/arch/arm/mach-mx6/Makefile
--- a/arch/arm/mach-mx6/Makefile	2014-01-09 09:25:00.379247041 +0100
+++ b/arch/arm/mach-mx6/Makefile	2014-01-09 12:18:40.251033547 +0100
@@ -22,3 +22,4 @@
 obj-$(CONFIG_USB_EHCI_ARC_H1) += usb_h1.o
 obj-$(CONFIG_MACH_IMX_BLUETOOTH_RFKILL) += mx6_bt_rfkill.o
 obj-$(CONFIG_PCI_MSI) += msi.o
+obj-$(CONFIG_MACH_TIBIDABO) += board-tibidabo.o
diff -Naur a/arch/arm/mach-mx6/mx6_fec.c b/arch/arm/mach-mx6/mx6_fec.c
--- a/arch/arm/mach-mx6/mx6_fec.c	2014-01-09 09:25:00.115250360 +0100
+++ b/arch/arm/mach-mx6/mx6_fec.c	2014-01-09 12:19:41.138268091 +0100
@@ -43,14 +43,14 @@
 	return 0;
 }
 
-void __init imx6_init_fec(struct fec_platform_data fec_data)
+struct platform_device * __init imx6_init_fec(struct fec_platform_data fec_data)
 {
 	fec_get_mac_addr(fec_data.mac);
 	if (!is_valid_ether_addr(fec_data.mac))
 		random_ether_addr(fec_data.mac);
 
 	if (cpu_is_mx6sl())
-		imx6sl_add_fec(&fec_data);
+		return imx6sl_add_fec(&fec_data);
 	else
-		imx6q_add_fec(&fec_data);
+		return imx6q_add_fec(&fec_data);
 }
diff -Naur a/arch/arm/plat-mxc/include/mach/common.h b/arch/arm/plat-mxc/include/mach/common.h
--- a/arch/arm/plat-mxc/include/mach/common.h	2014-01-09 09:24:55.679306127 +0100
+++ b/arch/arm/plat-mxc/include/mach/common.h	2014-01-09 17:34:32.075139658 +0100
@@ -76,7 +76,7 @@
 			unsigned long ckih1, unsigned long ckih2);
 extern int mx6sl_clocks_init(unsigned long ckil, unsigned long osc,
 			unsigned long ckih1, unsigned long ckih2);
-extern void imx6_init_fec(struct fec_platform_data fec_data);
+extern struct platform_device * imx6_init_fec(struct fec_platform_data fec_data);
 extern int mxc91231_clocks_init(unsigned long fref);
 extern int mxc_register_gpios(void);
 extern int mxc_register_device(struct platform_device *pdev, void *data);
diff -Naur a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
--- a/arch/arm/tools/mach-types	2014-01-09 09:24:56.643294008 +0100
+++ b/arch/arm/tools/mach-types	2014-01-09 12:28:36.779534168 +0100
@@ -1120,4 +1120,5 @@
 mx6sl_arm2		MACH_MX6SL_ARM2		MX6SL_ARM2		4091
 mx6q_hdmidongle		MACH_MX6Q_HDMIDONGLE    MX6Q_HDMIDONGLE		4284
 mx6sl_evk		MACH_MX6SL_EVK		MX6SL_EVK		4307
+tibidabo        MACH_TIBIDABO       TIBIDABO        4822
 
diff -Naur a/drivers/mtd/devices/Kconfig b/drivers/mtd/devices/Kconfig
--- a/drivers/mtd/devices/Kconfig	2014-01-09 09:25:57.782525384 +0100
+++ b/drivers/mtd/devices/Kconfig	2014-01-09 12:42:48.764823262 +0100
@@ -102,6 +102,12 @@
 	help
 	  This option enables FAST_READ access supported by ST M25Pxx.
 
+config MTD_N25Q
+    tristate "Support Micron N25Q SPI flash chips"
+    depends on SPI_MASTER && EXPERIMENTAL
+    help
+        This enables access to Micron SPI N25Q flash chips.
+
 config MTD_SST25L
 	tristate "Support SST25L (non JEDEC) SPI Flash chips"
 	depends on SPI_MASTER
diff -Naur a/drivers/mtd/devices/Makefile b/drivers/mtd/devices/Makefile
--- a/drivers/mtd/devices/Makefile	2014-01-09 09:25:57.818524931 +0100
+++ b/drivers/mtd/devices/Makefile	2014-01-09 12:43:49.744056650 +0100
@@ -17,3 +17,4 @@
 obj-$(CONFIG_MTD_DATAFLASH)	+= mtd_dataflash.o
 obj-$(CONFIG_MTD_M25P80)	+= m25p80.o
 obj-$(CONFIG_MTD_SST25L)	+= sst25l.o
+obj-$(CONFIG_MTD_N25Q)      += n25q.o
diff -Naur a/drivers/mtd/devices/n25q.c b/drivers/mtd/devices/n25q.c
--- a/drivers/mtd/devices/n25q.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/mtd/devices/n25q.c	2014-01-09 12:49:40.799643283 +0100
@@ -0,0 +1,1020 @@
+/*
+ * MTD SPI driver for Micron N25Q serial flash chips
+ *
+ * Author: Alessandro Ratti, alessandro.ratti@silica.com
+ *
+ * Copyright (c) 2014, Avnet Emg.
+ *
+ * Some parts are based on m25p80.c by Mike Lavender.
+ *
+ * This code is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+/*
+ * WARNING
+ * This driver needs a lot of improvement to support all the features
+ * of this family of chips.
+ */
+
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/math64.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/mod_devicetable.h>
+
+#include <linux/mtd/cfi.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+
+/****************************************************************************/
+
+/*
+ * Operation codes
+ */
+
+#define OPCODE_READ_ID                          0x9F    /* Read JEDEC ID */
+
+#define OPCODE_READ_STATUS_REGISTER             0x05
+
+#define OPCODE_READ_FLAG_STATUS_REGISTER        0x70
+#define OPCODE_CLEAR_FLAG_STATUS_REGISTER       0x50
+
+#define OPCODE_ENTER_4_BYTE_ADDRESS_MODE        0xB7
+#define OPCODE_EXIT_4_BYTE_ADDRESS_MODE         0xE9
+
+#define OPCODE_WRITE_ENABLE                     0x06
+#define OPCODE_WRITE_DISABLE                    0x04
+
+#define OPCODE_READ                             0x03
+#define OPCODE_4_BYTE_READ                      0x13
+
+#define OPCODE_PAGE_PROGRAM                     0x02
+
+#define OPCODE_DIE_ERASE                        0xC4
+#define OPCODE_SUBSECTOR_ERASE                  0x20
+#define OPCODE_SECTOR_ERASE                     0xD8
+
+/****************************************************************************/
+
+/*
+ * Bits masks
+ */
+
+#define BIT7                                    0x80
+#define BIT6                                    0x40
+#define BIT5                                    0x20
+#define BIT4                                    0x10
+#define BIT3                                    0x08
+#define BIT2                                    0x04
+#define BIT1                                    0x02
+#define BIT0                                    0x01
+
+#define STATUS_REGISTER__WRITE_IN_PROGESS       BIT0
+
+#define FLAG_STATUS_REGISTER__ERASE             BIT5
+#define FLAG_STATUS_REGISTER__PROGRAM           BIT4
+#define FLAG_STATUS_REGISTER__PROTECTION        BIT1
+
+/****************************************************************************/
+
+/*
+ * Device table
+ */
+
+struct flash_info
+{
+    /* JEDEC id zero means "no ID" (most older chips); otherwise it has
+     * a high byte of zero plus three data bytes: the manufacturer id,
+     * then a two byte device id.
+     */
+    u32                 jedec_id;
+    u16                 ext_id;
+    /* The size listed here is what works with OPCODE_SE, which isn't
+     * necessarily called a "sector" by the vendor.
+     */
+    unsigned            sector_size;
+    u16                 n_sectors;
+    u16                 page_size;
+    u16                 addr_width;
+    unsigned            subsector_size;
+    unsigned            die_size;
+    u16                 n_die;
+    unsigned long       longest_operation_jiffies;
+};
+
+#define INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _subsector_size, _die_size, _n_die, _longest_operation_jiffies)  \
+    ((kernel_ulong_t)&(struct flash_info) {                                                                                 \
+        .jedec_id                   = (_jedec_id),                                                                          \
+        .ext_id                     = (_ext_id),                                                                            \
+        .sector_size                = (_sector_size),                                                                       \
+        .n_sectors                  = (_n_sectors),                                                                         \
+        .page_size                  = 256,                                                                                  \
+        .subsector_size             = (_subsector_size),                                                                    \
+        .die_size                   = (_die_size),                                                                          \
+        .n_die                      = (_n_die),                                                                             \
+        .longest_operation_jiffies  = (_longest_operation_jiffies)                                                          \
+    })
+
+static const struct spi_device_id
+    n25q_ids[]                      =
+{
+    { "n25q00aa", INFO( 0x20ba21, 0, 64 * 1024, 2048, 4 * 1024, 32 * 1024 * 1024, 4, 480 * HZ ) },
+    {},
+};
+MODULE_DEVICE_TABLE(spi, n25q_ids);
+
+/****************************************************************************/
+
+/*
+ * Internal driver data
+ */
+
+struct n25q
+{
+    struct spi_device   *spi;
+    struct mutex        lock;
+    struct mtd_info     mtd;
+    unsigned            partitioned:1;
+    unsigned            die_size;
+    u16                 n_die;   
+    u16                 page_size;
+    u16                 addr_width;
+    unsigned            sector_size;
+    unsigned            subsector_size;
+    unsigned long       longest_operation_jiffies;
+};
+
+static inline struct n25q *mtd_to_n25q( struct mtd_info *mtd )
+{
+    return container_of( mtd, struct n25q, mtd );
+}
+
+/****************************************************************************/
+
+/*
+ * Internal helper functions
+ */
+
+static inline void n25q_addr2cmd( struct n25q *flash, unsigned int addr, u8 *cmd )
+{
+    /* opcode is in cmd[0] */
+    cmd[1]              = addr >> (flash->addr_width * 8 -  8);
+    cmd[2]              = addr >> (flash->addr_width * 8 - 16);
+    cmd[3]              = addr >> (flash->addr_width * 8 - 24);
+    if( flash->addr_width == 4 )
+    {
+        cmd[4]          = addr;
+    }
+}
+
+static inline int read_status_register( struct n25q *flash, u8 *status_register_value )
+{
+    u8
+        command         = OPCODE_READ_STATUS_REGISTER;
+    return spi_write_then_read( flash->spi, &command, 1, status_register_value, 1 );
+}
+
+static inline int read_flag_status_register( struct n25q *flash, u8 *flag_status_register_value )
+{
+    u8
+        command         = OPCODE_READ_FLAG_STATUS_REGISTER;
+    return spi_write_then_read( flash->spi, &command, 1, flag_status_register_value, 1 );
+}
+
+static inline int clear_flag_status_register( struct n25q *flash )
+{
+    u8
+        command         = OPCODE_CLEAR_FLAG_STATUS_REGISTER;
+    return spi_write( flash->spi, &command, 1 );
+}
+
+static inline int enter_4_byte_address_mode( struct n25q *flash )
+{
+    u8
+        command         = OPCODE_ENTER_4_BYTE_ADDRESS_MODE;
+    return spi_write( flash->spi, &command, 1 );
+}
+
+static inline int exit_4_byte_address_mode( struct n25q *flash )
+{
+    u8
+        command         = OPCODE_EXIT_4_BYTE_ADDRESS_MODE;
+    return spi_write( flash->spi, &command, 1 );
+}
+
+static inline int write_enable( struct n25q *flash )
+{
+    u8
+        command         = OPCODE_WRITE_ENABLE;
+    return spi_write( flash->spi, &command, 1 );
+}
+
+static inline int write_disable( struct n25q *flash )
+{
+    u8
+        command         = OPCODE_WRITE_DISABLE;
+    return spi_write( flash->spi, &command, 1 );
+}
+
+static int wait_till_ready( struct n25q *flash, unsigned long max_time )
+{
+    unsigned long
+        deadline;
+    u8
+        status_register_value;
+
+    deadline            = jiffies + max_time;
+
+    do
+    {
+        if( read_status_register( flash, &status_register_value ) )
+            break;
+        else if( !( status_register_value & STATUS_REGISTER__WRITE_IN_PROGESS ) )
+            return 0;
+
+        cond_resched();
+
+    }while( !time_after_eq( jiffies, deadline ) );
+
+    return 1;
+}
+
+/****************************************************************************/
+
+/*
+ * MTD implementation
+ */
+
+static int n25q_read(struct mtd_info *mtd, loff_t from, size_t len,
+    size_t *retlen, u_char *buf)
+{
+    struct n25q
+        *flash              = mtd_to_n25q( mtd );
+    struct spi_transfer
+        t[ 2 ];
+    struct spi_message
+        m;
+    u8
+        command[5];
+
+    DEBUG(MTD_DEBUG_LEVEL2, "%s: %s %s 0x%08x, len %zd\n",
+            dev_name(&flash->spi->dev), __func__, "from",
+            (u32)from, len);
+
+    /* sanity checks */
+    if( !len )
+        return 0;
+
+    if( from + len > flash->mtd.size )
+        return -EINVAL;
+
+    spi_message_init( &m );
+    memset( t, 0, (sizeof t) );
+
+    /* Set up the write data buffer. */
+    n25q_addr2cmd( flash, from, command );
+    if( flash->addr_width == 4 )
+    {
+        command[0]                  = OPCODE_4_BYTE_READ;
+    }
+    else
+    {
+        command[0]                  = OPCODE_READ;
+    }
+    t[0].tx_buf                     = command;
+    t[0].len                        = flash->addr_width + 1;
+    spi_message_add_tail( &t[0], &m );
+
+    t[1].rx_buf                     = buf;
+    t[1].len                        = len;
+    spi_message_add_tail( &t[1], &m );
+
+    *retlen                         = 0;
+
+    mutex_lock( &flash->lock );
+
+    if( wait_till_ready( flash, flash->longest_operation_jiffies ) )
+    {
+        goto n25q_read_exit_with_error;
+    }
+
+    if( flash->addr_width == 4 )
+    {
+        if( write_enable( flash ) || enter_4_byte_address_mode( flash ) )
+        {
+            goto n25q_read_exit_with_error;
+        }
+    }
+
+    spi_sync( flash->spi, &m );
+
+    if( flash->addr_width == 4 )
+    {
+        if( write_enable( flash ) || exit_4_byte_address_mode( flash ) )
+        {
+            goto n25q_read_exit_with_error;
+        }
+    }
+
+    *retlen                         = m.actual_length - flash->addr_width - 1;
+
+    mutex_unlock( &flash->lock );    
+    return 0;
+
+n25q_read_exit_with_error:
+    mutex_unlock( &flash->lock );
+    return 1;
+}
+
+static int n25q_setup_for_page_program( struct n25q *flash )
+{
+    if(
+        wait_till_ready( flash, flash->longest_operation_jiffies )  ||
+        write_enable( flash )
+    )
+    {
+        return 1;
+    }
+    if( flash->addr_width == 4 )
+    {
+        if( enter_4_byte_address_mode( flash ) || write_enable( flash ) )
+        {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+static int n25q_wait_for_page_program( struct n25q *flash )
+{
+    u8
+        flag_status_register_value;
+    if(
+        wait_till_ready( flash, flash->longest_operation_jiffies )      ||
+        read_flag_status_register( flash, &flag_status_register_value ) ||
+        clear_flag_status_register( flash )
+    )
+    {
+        return 1;
+    }
+    if( flash->addr_width == 4 )
+    {
+        if( write_enable( flash ) || exit_4_byte_address_mode( flash ) )
+        {
+            return 1;
+        }
+    }
+    if(
+        ( flag_status_register_value & FLAG_STATUS_REGISTER__PROGRAM    ) &&
+        ( flag_status_register_value & FLAG_STATUS_REGISTER__PROTECTION )
+    )
+    {
+        return 1;
+    }
+    return 0;
+}
+
+static int n25q_write(struct mtd_info *mtd, loff_t to, size_t len,
+    size_t *retlen, const u_char *buf)
+{
+    struct n25q
+        *flash                      = mtd_to_n25q( mtd );
+    u32
+        page_offset,
+        page_size;
+    struct spi_transfer
+        t[2];
+    struct spi_message
+        m;
+    u8
+        command[5];
+
+    DEBUG(MTD_DEBUG_LEVEL2, "%s: %s %s 0x%08x, len %zd\n",
+            dev_name(&flash->spi->dev), __func__, "to",
+            (u32)to, len);
+
+    *retlen                     = 0;
+
+    if( !len )
+        return 0;
+
+    if( to + len > flash->mtd.size )
+        return -EINVAL;
+
+    spi_message_init( &m );
+    memset( t, 0, (sizeof t) );
+
+    command[0]                  = OPCODE_PAGE_PROGRAM;
+    n25q_addr2cmd( flash, to, command );
+
+    t[0].tx_buf                 = command;
+    t[0].len                    = flash->addr_width + 1;
+    spi_message_add_tail( &t[0], &m );
+
+    t[1].tx_buf                 = buf;
+    spi_message_add_tail( &t[1], &m );
+
+    mutex_lock( &flash->lock );
+   
+    if( n25q_setup_for_page_program( flash ) )
+    {
+        goto n25q_write_exit_with_error;
+    }
+
+    page_offset                 = to & ( flash->page_size - 1 );
+
+    if( page_offset + len <= flash->page_size )
+    {
+        t[1].len                = len;
+
+        spi_sync( flash->spi, &m );
+
+        *retlen                 = m.actual_length - flash->addr_width - 1;
+    }
+    else
+    {
+        u32 i;
+
+        page_size               = flash->page_size - page_offset;
+
+        t[1].len                = page_size;
+        spi_sync( flash->spi, &m );
+
+        *retlen                 = m.actual_length - flash->addr_width - 1;
+
+        for( i = page_size; i < len; i += page_size )
+        {
+            if( n25q_wait_for_page_program( flash ) )
+            {
+                goto n25q_write_exit_with_error;
+            }
+
+            page_size           = len - i;
+            if( page_size > flash->page_size )
+                page_size       = flash->page_size;
+
+            n25q_addr2cmd( flash, to + i, command );
+
+            t[1].tx_buf         = buf + i;
+            t[1].len            = page_size;
+
+            if( n25q_setup_for_page_program( flash ) )
+            {
+                goto n25q_write_exit_with_error;
+            }
+
+            spi_sync( flash->spi, &m );
+
+            *retlen             += m.actual_length - flash->addr_width - 1;
+        }
+    }
+        
+    if( n25q_wait_for_page_program( flash ) )
+    {
+        goto n25q_write_exit_with_error;
+    }
+
+    mutex_unlock( &flash->lock );
+
+    return 0;
+
+n25q_write_exit_with_error:
+    mutex_unlock( &flash->lock );
+    return 1;
+}
+
+static int n25q_erase_die( struct n25q *flash, u32 die_number )
+{
+    u8
+        command[5],
+        flag_status_register_value;
+
+    if( die_number >= flash->n_die )
+    {
+        return -EINVAL;
+    }
+
+    if( wait_till_ready( flash, flash->longest_operation_jiffies ) )
+    {
+        return 1;
+    }
+
+    command[0]                  = OPCODE_DIE_ERASE;
+    n25q_addr2cmd( flash, die_number * flash->die_size, command );
+
+    if( flash->addr_width == 4 )
+    {
+        if( write_enable( flash ) || enter_4_byte_address_mode( flash ) )
+        {
+            return 1;
+        }
+    }
+    if( write_enable( flash ) )
+    {
+        return 1;
+    }
+
+    spi_write( flash->spi, &command, flash->addr_width + 1 );
+
+    if(
+        wait_till_ready( flash, flash->longest_operation_jiffies )      ||
+        read_flag_status_register( flash, &flag_status_register_value ) ||
+        clear_flag_status_register( flash )
+    )
+    {
+        return 1;
+    }
+
+    if( flash->addr_width == 4 )
+    {
+        if( write_enable( flash ) || exit_4_byte_address_mode( flash ) )
+        {
+            return 1;
+        }
+    }
+
+    if(
+        ( flag_status_register_value & FLAG_STATUS_REGISTER__PROTECTION ) &&
+        ( flag_status_register_value & FLAG_STATUS_REGISTER__ERASE      )
+    )
+    {
+        return 1;
+    }
+
+    return 0;
+}
+
+static int n25q_erase_chip( struct n25q *flash )
+{
+    u32
+        i,
+        retval;
+
+    DEBUG(MTD_DEBUG_LEVEL3, "%s: %s %lldKiB\n",
+          dev_name(&flash->spi->dev), __func__,
+          (long long)(flash->mtd.size >> 10));
+
+    for( i = 0; i < flash->n_die; i++ )
+    {
+        if( ( retval = n25q_erase_die( flash, i ) ) )
+        {
+            return retval;
+        }
+    }
+    return 0;
+}
+
+static int n25q_erase_subsector( struct n25q *flash, u32 offset )
+{
+    u8
+        command[5],
+        flag_status_register_value;
+
+    DEBUG(MTD_DEBUG_LEVEL3, "%s: %s %dKiB at 0x%08x\n",
+            dev_name(&flash->spi->dev), __func__,
+            flash->mtd.erasesize / 1024, offset);
+
+    if( offset >= flash->mtd.size )
+        return 1;
+
+    command[0]                  = OPCODE_SUBSECTOR_ERASE;
+    n25q_addr2cmd( flash, offset, command );
+
+    if( wait_till_ready( flash, flash->longest_operation_jiffies ) || write_enable( flash ) )
+    {
+        return 1;
+    }
+
+    if( flash->addr_width == 4 )
+    {
+        if( enter_4_byte_address_mode( flash ) || write_enable( flash ) )
+        {
+            return 1;
+        }
+    }
+    
+    spi_write( flash->spi, &command, flash->addr_width + 1 );
+
+    if(
+        wait_till_ready( flash, flash->longest_operation_jiffies )      ||
+        read_flag_status_register( flash, &flag_status_register_value ) ||
+        clear_flag_status_register( flash )
+    )
+    {
+        return 1;
+    }
+    if( flash->addr_width == 4 )
+    {
+        if( write_enable( flash ) || exit_4_byte_address_mode( flash ) )
+        {
+            return 1;
+        }
+    }
+    if(
+        ( flag_status_register_value & FLAG_STATUS_REGISTER__PROTECTION ) &&
+        ( flag_status_register_value & FLAG_STATUS_REGISTER__ERASE      )
+    )
+    {
+        return 1;
+    }
+    return 0;
+}
+
+static int n25q_erase_sector( struct n25q *flash, u32 offset )
+{
+    u8
+        command[5],
+        flag_status_register_value;
+
+    DEBUG(MTD_DEBUG_LEVEL3, "%s: %s %dKiB at 0x%08x\n",
+            dev_name(&flash->spi->dev), __func__,
+            flash->mtd.erasesize / 1024, offset);
+
+    if( offset >= flash->mtd.size )
+        return 1;
+
+    command[0]                  = OPCODE_SECTOR_ERASE;
+    n25q_addr2cmd( flash, offset, command );
+
+    if( wait_till_ready( flash, flash->longest_operation_jiffies ) || write_enable( flash ) )
+    {
+        return 1;
+    }
+    if( flash->addr_width == 4 )
+    {
+        if( enter_4_byte_address_mode( flash ) || write_enable( flash ) )
+        {
+            return 1;
+        }
+    }
+    
+    spi_write( flash->spi, &command, flash->addr_width + 1 );
+
+    if(
+        wait_till_ready( flash, flash->longest_operation_jiffies )      ||
+        read_flag_status_register( flash, &flag_status_register_value ) ||
+        clear_flag_status_register( flash )
+    )
+    {
+        return 1;
+    }
+
+    if( flash->addr_width == 4 )
+    {
+        if( write_enable( flash ) || exit_4_byte_address_mode( flash ) )
+        {
+            return 1;
+        }
+    }
+    if(
+        ( flag_status_register_value & FLAG_STATUS_REGISTER__PROTECTION ) &&
+        ( flag_status_register_value & FLAG_STATUS_REGISTER__ERASE      )
+    )
+    {
+        return 1;
+    }
+
+    return 0;
+}
+
+static int n25q_erase( struct mtd_info *mtd, struct erase_info *instr )
+{
+    struct n25q
+        *flash                      = mtd_to_n25q( mtd );
+    u32
+        addr,
+        len;
+
+    DEBUG(MTD_DEBUG_LEVEL2, "%s: %s %s 0x%llx, len %lld\n",
+          dev_name(&flash->spi->dev), __func__, "at",
+          (long long)instr->addr, (long long)instr->len);
+
+    if( instr->addr + instr->len > flash->mtd.size )
+    {
+        return -EINVAL;
+    }
+    if( (uint32_t)instr->len % mtd->erasesize )
+    {
+        return -EINVAL;
+    }
+    if( (uint32_t)instr->addr % mtd->erasesize )
+    {
+        return -EINVAL;
+    }
+    addr                            = instr->addr;
+    len                             = instr->len;
+
+    mutex_lock( &flash->lock );
+
+    if( len == flash->mtd.size )
+    {
+        if( n25q_erase_chip( flash ) )
+        {
+            instr->state            = MTD_ERASE_FAILED;
+            mutex_unlock( &flash->lock );
+            return -EIO;
+        }
+    }
+    else
+    {
+        while( len )
+        {
+            if( !flash->subsector_size || ( ( ( addr % flash->sector_size ) == 0 ) && ( len >= flash->sector_size ) ) )
+            {
+                if( n25q_erase_sector( flash, addr ) )
+                {
+                    instr->state    = MTD_ERASE_FAILED;
+                    mutex_unlock( &flash->lock );
+                    return -EIO;               
+                }
+                addr                += flash->sector_size;
+                len                 -= flash->sector_size;
+            }
+            else
+            {
+                if( n25q_erase_subsector( flash, addr ) )
+                {
+                    instr->state    = MTD_ERASE_FAILED;
+                    mutex_unlock( &flash->lock );
+                    return -EIO;
+                }
+                addr                += flash->subsector_size;
+                len                 -= flash->subsector_size;               
+            }
+        }
+    }
+
+    mutex_unlock( &flash->lock );
+
+    instr->state                    = MTD_ERASE_DONE;
+    mtd_erase_callback( instr );
+
+    return 0;
+}
+
+static const struct spi_device_id *__devinit jedec_probe( struct spi_device *spi )
+{
+    int
+        tmp;
+    u8
+        command                 = OPCODE_READ_ID,
+        id[20];
+    u32
+        jedec;
+    u16
+        ext_jedec;
+    struct flash_info
+        *info;
+
+    tmp                         = spi_write_then_read( spi, &command, 1, id, 20 );
+    if( tmp < 0 )
+    {
+        DEBUG( MTD_DEBUG_LEVEL0, "%s: error %d reading JEDEC ID\n", dev_name( &spi->dev ), tmp );
+        return ERR_PTR(tmp);
+    }
+    jedec                       =  id[0];
+    jedec                       =  jedec << 8;
+    jedec                       |= id[1];
+    jedec                       =  jedec << 8;
+    jedec                       |= id[2];
+
+    ext_jedec                   =  id[3] << 8 | id[4];
+
+    for( tmp = 0; tmp < ARRAY_SIZE( n25q_ids ) - 1; tmp++ )
+    {
+        info                    = (void *)n25q_ids[ tmp ].driver_data;
+        if( info->jedec_id == jedec )
+        {
+            if( info->ext_id != 0 && info->ext_id != ext_jedec )
+                continue;
+            return &n25q_ids[ tmp ];
+        }
+    }
+    dev_err( &spi->dev, "unrecognized JEDEC id %06x\n", jedec );
+    return ERR_PTR( -ENODEV );
+}
+
+static int __devinit n25q_probe( struct spi_device *spi )
+{
+    const struct spi_device_id
+        *id                             = spi_get_device_id( spi );
+    struct flash_platform_data
+        *data;
+    struct n25q
+        *flash;
+    struct flash_info
+        *info;
+    unsigned
+        i;
+    struct mtd_partition
+        *parts                          = NULL;
+    int
+        nr_parts                        = 0;
+
+    data                                = spi->dev.platform_data;
+    if( data && data->type )
+    {
+        const struct spi_device_id
+            *plat_id;
+
+        for( i = 0; i < ARRAY_SIZE( n25q_ids ) - 1; i++ )
+        {
+            plat_id                     = &n25q_ids[ i ];
+            if( strcmp( data->type, plat_id->name ) )
+                continue;
+            break;
+        }
+
+        if( i < ARRAY_SIZE( n25q_ids ) - 1 )
+            id                          = plat_id;
+        else
+            dev_warn( &spi->dev, "unrecognized id %s\n", data->type );
+    }
+
+    info                                = (void *)id->driver_data;
+
+    if( info->jedec_id )
+    {
+        const struct spi_device_id
+            *jid;
+
+        jid                             = jedec_probe( spi );
+        if( IS_ERR( jid ) )
+        {
+            return PTR_ERR( jid );
+        }
+        else if( jid != id )
+        {
+            dev_warn( &spi->dev, "found %s, expected %s\n", jid->name, id->name );
+            id                          = jid;
+            info                        = (void *)jid->driver_data;
+        }
+    }
+
+    flash                               = kzalloc( sizeof *flash, GFP_KERNEL );
+    if( !flash )
+        return -ENOMEM;
+
+    flash->spi                          = spi;
+    mutex_init( &flash->lock );
+    dev_set_drvdata( &spi->dev, flash );
+
+    if( data && data->name )
+    {
+        flash->mtd.name                 = data->name;
+    }
+    else
+    {
+        flash->mtd.name                 = dev_name( &spi->dev );
+    }
+
+    flash->mtd.type                     = MTD_NORFLASH;
+    flash->mtd.writesize                = 1;
+    flash->mtd.flags                    = MTD_CAP_NORFLASH;
+    flash->mtd.size                     = info->sector_size * info->n_sectors;
+    flash->mtd.erase                    = n25q_erase; 
+    flash->mtd.read                     = n25q_read;
+    flash->mtd.write                    = n25q_write;
+    flash->mtd.erasesize                = info->sector_size;
+    flash->mtd.dev.parent               = &spi->dev;
+    flash->n_die                        = info->n_die;
+    flash->die_size                     = info->die_size;
+    flash->page_size                    = info->page_size;
+    flash->sector_size                  = info->sector_size;
+    flash->subsector_size               = info->subsector_size;
+    flash->longest_operation_jiffies    = info->longest_operation_jiffies;
+    flash->mtd.writebufsize             = flash->page_size;
+    if( flash->mtd.size > 0x1000000 )
+    {
+        flash->addr_width               = 4;
+    }
+    else
+    {
+        flash->addr_width               = 3;
+    }
+
+    dev_info( &spi->dev, "%s (%lld Kbytes)\n", id->name, (long long)flash->mtd.size >> 10 );
+
+    DEBUG(MTD_DEBUG_LEVEL2,
+        "mtd .name = %s, .size = 0x%llx (%lldMiB) "
+            ".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\n",
+        flash->mtd.name,
+        (long long)flash->mtd.size, (long long)(flash->mtd.size >> 20),
+        flash->mtd.erasesize, flash->mtd.erasesize / 1024,
+        flash->mtd.numeraseregions);
+
+    if( flash->mtd.numeraseregions )
+    {
+        for( i = 0; i < flash->mtd.numeraseregions; i++ )
+        {
+            DEBUG(MTD_DEBUG_LEVEL2,
+                "mtd.eraseregions[%d] = { .offset = 0x%llx, "
+                ".erasesize = 0x%.8x (%uKiB), "
+                ".numblocks = %d }\n",
+                i, (long long)flash->mtd.eraseregions[i].offset,
+                flash->mtd.eraseregions[i].erasesize,
+                flash->mtd.eraseregions[i].erasesize / 1024,
+                flash->mtd.eraseregions[i].numblocks);
+        }
+    }
+
+    /* partitions should match sector boundaries; and it may be good to
+     * use readonly partitions for writeprotected sectors (BP2..BP0).
+     */
+    if( mtd_has_cmdlinepart() )
+    {
+        static const char
+            *part_probes[]              = { "cmdlinepart", NULL, };
+
+        nr_parts                        = parse_mtd_partitions( &flash->mtd, part_probes, &parts, 0 );
+    }
+
+    if( nr_parts <= 0 && data && data->parts )
+    {
+        parts                           = data->parts;
+        nr_parts                        = data->nr_parts;
+    }
+
+#ifdef CONFIG_MTD_OF_PARTS
+    if( nr_parts <= 0 && spi->dev.of_node )
+    {
+        nr_parts                        = of_mtd_parse_partitions( &spi->dev, spi->dev.of_node, &parts );
+    }
+#endif
+
+    if( nr_parts > 0 )
+    {
+        for( i = 0; i < nr_parts; i++ )
+        {
+            DEBUG(MTD_DEBUG_LEVEL2, "partitions[%d] = "
+                  "{.name = %s, .offset = 0x%llx, "
+                  ".size = 0x%llx (%lldKiB) }\n",
+                  i, parts[i].name,
+                  (long long)parts[i].offset,
+                  (long long)parts[i].size,
+                  (long long)(parts[i].size >> 10));
+        }
+        flash->partitioned              = 1;
+    }
+
+    return mtd_device_register( &flash->mtd, parts, nr_parts ) == 1 ? -ENODEV : 0;
+}
+
+static int __devexit n25q_remove( struct spi_device *spi )
+{
+    struct n25q
+        *flash              = dev_get_drvdata( &spi->dev );
+    int
+        status;
+
+    status                  = mtd_device_unregister( &flash->mtd );
+    if( status == 0 )
+    {
+        kfree( flash );
+    }
+    return 0;
+}
+
+static struct spi_driver
+    n25q_driver             =
+{
+    .driver                 =
+    {
+        .name               = "n25q00aa",
+        .bus                = &spi_bus_type,
+        .owner              = THIS_MODULE,
+    },
+    .id_table               = n25q_ids,
+    .probe                  = n25q_probe,
+    .remove                 = __devexit_p( n25q_remove ),
+
+};
+
+static int __init n25q_init(void)
+{
+    return spi_register_driver( &n25q_driver );
+}
+
+static void __exit n25q_exit(void)
+{
+    spi_unregister_driver( &n25q_driver );
+}
+
+module_init( n25q_init );
+module_exit( n25q_exit );
+
+MODULE_LICENSE( "GPL" );
+MODULE_AUTHOR( "Alessandro Ratti" );
+MODULE_DESCRIPTION( "MTD SPI driver for Micron N25Q flash chips" );
diff -Naur a/drivers/net/fec.c b/drivers/net/fec.c
--- a/drivers/net/fec.c	2014-01-09 09:27:51.365097458 +0100
+++ b/drivers/net/fec.c	2014-02-04 17:41:22.046754419 +0100
@@ -49,6 +49,7 @@
 #include <linux/fec.h>
 
 #include <asm/cacheflush.h>
+#include <asm/mach-types.h>
 
 #ifndef CONFIG_ARM
 #include <asm/coldfire.h>
@@ -156,9 +157,15 @@
 
 /* The FEC stores dest/src/type, data, and checksum for receive packets.
  */
-#define PKT_MAXBUF_SIZE		1518
-#define PKT_MINBUF_SIZE		64
-#define PKT_MAXBLR_SIZE		1520
+#ifndef CONFIG_MACH_TIBIDABO
+    #define PKT_MAXBUF_SIZE		1518
+    #define PKT_MINBUF_SIZE		64
+    #define PKT_MAXBLR_SIZE		1520
+#else
+    #define PKT_MAXBUF_SIZE		1522
+    #define PKT_MINBUF_SIZE		64
+    #define PKT_MAXBLR_SIZE		1536
+#endif
 
 /* Pause frame feild and FIFO threshold */
 #define FEC_ENET_FCE		(1 << 5)
@@ -1051,19 +1058,26 @@
 
 	fep->phy_dev = NULL;
 
-	/* check for attached phy */
-	for (phy_id = 0; (phy_id < PHY_MAX_ADDR); phy_id++) {
-		if ((fep->mii_bus->phy_mask & (1 << phy_id)))
-			continue;
-		if (fep->mii_bus->phy_map[phy_id] == NULL)
-			continue;
-		if (fep->mii_bus->phy_map[phy_id]->phy_id == 0)
-			continue;
-		if (dev_id--)
-			continue;
-		strncpy(mdio_bus_id, fep->mii_bus->id, MII_BUS_ID_SIZE);
-		break;
-	}
+    if( machine_is_tibidabo() )
+    {
+        phy_id                  = PHY_MAX_ADDR;
+    }
+    else
+    {
+        /* check for attached phy */
+        for (phy_id = 0; (phy_id < PHY_MAX_ADDR); phy_id++) {
+            if ((fep->mii_bus->phy_mask & (1 << phy_id)))
+                continue;
+            if (fep->mii_bus->phy_map[phy_id] == NULL)
+                continue;
+            if (fep->mii_bus->phy_map[phy_id]->phy_id == 0)
+                continue;
+            if (dev_id--)
+                continue;
+            strncpy(mdio_bus_id, fep->mii_bus->id, MII_BUS_ID_SIZE);
+            break;
+        }
+    }
 
 	if (phy_id >= PHY_MAX_ADDR) {
 		printk(KERN_INFO "%s: no PHY, assuming direct connection "
@@ -1929,7 +1943,8 @@
 
 	/* Carrier starts down, phylib will bring it up */
 	netif_carrier_off(ndev);
-	clk_disable(fep->clk);
+    if( !machine_is_tibidabo() )
+	    clk_disable(fep->clk);
 
 	INIT_DELAYED_WORK(&fep->fixup_trigger_tx, fixup_trigger_tx_func);
 
diff -Naur a/drivers/net/fec.h b/drivers/net/fec.h
--- a/drivers/net/fec.h	2014-01-09 09:27:20.805481644 +0100
+++ b/drivers/net/fec.h	2014-01-09 13:38:11.119055613 +0100
@@ -49,6 +49,7 @@
 #define FEC_R_FIFO_RSEM		0x194 /* Receive FIFO section empty threshold */
 #define FEC_R_FIFO_RAEM		0x198 /* Receive FIFO almost empty threshold */
 #define FEC_R_FIFO_RAFL		0x19c /* Receive FIFO almost full threshold */
+#define FEC_FTRL            0x1b0 /* Frame truncation receive length */
 #define FEC_MIIGSK_CFGR		0x300 /* MIIGSK Configuration reg */
 #define FEC_MIIGSK_ENR		0x308 /* MIIGSK Enable reg */
 
diff -Naur a/drivers/video/mxc/ldb.c b/drivers/video/mxc/ldb.c
--- a/drivers/video/mxc/ldb.c	2014-01-09 09:26:16.746286977 +0100
+++ b/drivers/video/mxc/ldb.c	2014-01-09 16:35:53.507374045 +0100
@@ -128,6 +128,14 @@
 	 0,
 	 FB_VMODE_NONINTERLACED,
 	 FB_MODE_IS_DETAILED,},
+ 	{
+	 "LDB-WVGA", 60, 800, 480, 31250,
+	 86, 42,
+	 32, 10,
+	 128, 2,
+	 0,
+	 FB_VMODE_NONINTERLACED,
+	 FB_MODE_IS_DETAILED,},        
 };
 static int ldb_modedb_sz = ARRAY_SIZE(ldb_modedb);
 
diff -Naur a/include/linux/if_ether.h b/include/linux/if_ether.h
--- a/include/linux/if_ether.h	2014-01-09 09:24:10.063879591 +0100
+++ b/include/linux/if_ether.h	2014-02-04 17:42:09.402159081 +0100
@@ -31,7 +31,11 @@
 #define ETH_ALEN	6		/* Octets in one ethernet addr	 */
 #define ETH_HLEN	14		/* Total octets in header.	 */
 #define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
-#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#ifdef CONFIG_MACH_TIBIDABO
+    #define ETH_DATA_LEN	1492		/* Max. octets in payload	 */
+#else
+    #define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#endif
 #define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
 #define ETH_FCS_LEN	4		/* Octets in the FCS		 */
 
diff -Naur a/net/dsa/mv88e6123_61_65.c b/net/dsa/mv88e6123_61_65.c
--- a/net/dsa/mv88e6123_61_65.c	2014-01-09 09:28:07.760891334 +0100
+++ b/net/dsa/mv88e6123_61_65.c	2014-01-09 21:06:39.797826035 +0100
@@ -13,6 +13,7 @@
 #include <linux/phy.h>
 #include "dsa_priv.h"
 #include "mv88e6xxx.h"
+#include <asm/mach-types.h>
 
 static char *mv88e6123_61_65_probe(struct mii_bus *bus, int sw_addr)
 {
@@ -256,16 +257,32 @@
 	 */
 	REG_WRITE(addr, 0x07, 0x0000);
 
-	/*
-	 * Port Control 2: don't force a good FCS, set the maximum
-	 * frame size to 10240 bytes, don't let the switch add or
-	 * strip 802.1q tags, don't discard tagged or untagged frames
-	 * on this port, do a destination address lookup on all
-	 * received packets as usual, disable ARP mirroring and don't
-	 * send a copy of all transmitted/received frames on this port
-	 * to the CPU.
-	 */
-	REG_WRITE(addr, 0x08, 0x2080);
+    if( !machine_is_tibidabo() )
+    {
+        /*
+         * Port Control 2: don't force a good FCS, set the maximum
+         * frame size to 10240 bytes, don't let the switch add or
+         * strip 802.1q tags, don't discard tagged or untagged frames
+         * on this port, do a destination address lookup on all
+         * received packets as usual, disable ARP mirroring and don't
+         * send a copy of all transmitted/received frames on this port
+         * to the CPU.
+         */
+        REG_WRITE(addr, 0x08, 0x2080);
+    }
+    else
+    {
+        /*
+         * Port Control 2: don't force a good FCS, set the maximum
+         * frame size to 1522 bytes, don't let the switch add or
+         * strip 802.1q tags, don't discard tagged or untagged frames
+         * on this port, do a destination address lookup on all
+         * received packets as usual, disable ARP mirroring and don't
+         * send a copy of all transmitted/received frames on this port
+         * to the CPU.
+         */
+        REG_WRITE(addr, 0x08, 0x0080);
+    }
 
 	/*
 	 * Egress rate control: disable egress rate control.
